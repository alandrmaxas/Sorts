#include <stdio.h>
#include <stdlib.h>
#define MAX 1000 // ћаксимальный размер массива 

// ѕрототипы функций решил бахнуть по приколу, да и так удобнее, на мой взгл€д
void printf_arr(int a[], int n);
void swap(int* a, int* b);
void MMM(int a[], int n, int i);
void MMM_sort(int a[], int n);

int main() {
    int arr[MAX]; 
    for (int i = 0; i < MAX; ++i) { 
        arr[i] = rand();
    }
    int arr_size = sizeof(arr) / sizeof(arr[0]);

    printf("Size: %d\n", arr_size);
    printf("\nArray: ");
    printf_arr(arr, arr_size);
    printf("\n");

    MMM_sort(arr, arr_size);

    printf("\nSorted array: ");
    printf_arr(arr, arr_size);

    return 0;
}

// Ёта функци€ нужна дл€ вывода массива исходного и отсортированного, думаю тут ничего сложного нет 
void printf_arr(int a[], int n) {
    for (int i = 0; i < n; i++)
    {
        printf("%d ", a[i]);
    }
    printf("\n");

}

//‘ункци€ перестановки значений 
void swap(int* a, int* b) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
    // ѕросто махаем адреса местами, вроде тоже пон€тно
}

// Ёта функци€ просеивает через кучу/строит кучу
void MMM(int a[], int n, int i) {
    int largest = i; // передаваемое знаение в функцию (в данном случае за это отвечает i) приравниваем к наибольшему
    int l = 2 * i + 1; // тут иницилизируетс€ каждый левый дочерний элемент 
    int r = 2 * i + 2; // тут иницилизируетс€ каждый правый дочерний элемент

    if (l < n && a[l] > a[largest]) { // просто удостовер€емс€ что левый дочерний не выходит за размеры массива и провер€ем будет ли левый дочерний больше предполагаемого наибольшего
        largest = l; // тогда левый дочерний = наибольшему
    }
    if (r < n && a[r] > a[largest]) { // тоже самое и дл€ правого дочернего
        largest = r;
    }

    if (largest != i) {
        swap(&a[i], &a[largest]); // ¬ случае не соответсви€ переданного значени€ из "сортировки кучей" наибольшему мен€ем их местами и
        MMM(a, n, largest); // по новой выполн€ем эту функцию с новым 3-им значением (новое потому что выше мы его махнули с i-ым) 
    }
}

// —ортировка кучей
void MMM_sort(int a[], int n) {
    for (int i = n / 2 - 1; i >= 0; i--) {
        MMM(a, n, i);
    }
    // “ут мы сортируем нижний р€д пирамиды поэтому i = n / 2 - 1

    for (int i = n - 1; i > 0; i--) {
        swap(&a[0], &a[i]);
        MMM(a, i, 0);
    }
    //  ороче тут мен€ем местами остальные элементы и сортируем их
    // i = n - 1 потому что у нас столько индексов в массиве 
}